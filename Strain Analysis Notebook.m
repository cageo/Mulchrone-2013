(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["MultivariateStatistics`"]


AnalyzeImage[filename_]:=Module[{im,res,data},
(* you must pass in a valid filename from the directory *)
im = Import[filename];
im=Binarize[im];
im=ColorNegate[im];
(* Extract the various regions *)
res=WatershedComponents[im];
(* Grab the relevant data *)
data=ComponentMeasurements[res,{"EquivalentDiskRadius","Centroid","Length","Width","Orientation","Label"}];
(* Remove the first and largest data element as this is usually the background *)
data=Take[data,-(Length[data]-1)];
(* Display the data and numbered fitted components *)
Print[Show[res//Colorize,Table[Graphics[{White,Thick,GeometricTransformation[Circle[data[[i,2,2]],{data[[i,2,3]],data[[i,2,4]]}/2],RotationTransform[data[[i,2,5]],data[[i,2,2]]]],{Red,Text[Style[data[[i,2,6]],Medium],data[[i,2,2]],Background->White]}}],{i,1,Length[data]}],ImageSize->Scaled[1]]];
(* return both the data and the result *)
{data, res}
]


RefineImageData[origanalysis_,excludelist_,fittedellipses_:1]:=Module[{origdata, origres, data},
(* fittedellipses 1 means yes plot and 0 means no dont plot *)
origdata = origanalysis[[1]];
origres = origanalysis[[2]];
data = Select[origdata, MemberQ[excludelist,#[[2,6]]]==False&];
(* Display the filtered data and numbered fitted components *)
If[fittedellipses==1,
Print[
Show[origres//Colorize,Table[Graphics[{White,Thick,GeometricTransformation[Circle[data[[i,2,2]],{data[[i,2,3]],data[[i,2,4]]}/2],RotationTransform[data[[i,2,5]],data[[i,2,2]]]],{Red,Text[Style[data[[i,2,6]],Medium],data[[i,2,2]],Background->White]}}],{i,1,Length[data]}],ImageSize->Scaled[1]]
];
,
Print[Show[origres//Colorize,ImageSize->Scaled[1]]];
];
(* return both the data and the result *)
{data, origres}
]


ExtractData[analysis_]:=Module[{data},
data=analysis[[1]];
(* Get data into a usable format *)
data = Map[Flatten[#[[2]]]&,data];
(* Remove largest element as this is the background *)
data=Most[Sort[data]];
(* Create a pair of lists first for NN second for MRL *)
data={Take[data,All,{1,3}],Take[data,All,{4,6}]};
(* Output the data *)
data
(* note data[[1]] holds the data in the form {avradius,x,y} for input to Nearest Neighbour Analysis *)
(* note data[[2]] holds the data in the form {a,b,phi} for input to MRL Analysis *)
]


ExtractDataFromImage[filename_,visualoutput_]:=Module[{im,res,data},
(* you must pass in a valid filename from the directory *)
(* set visuloutput to 1 to get see the processed image *)
im = Import[filename];
im=Binarize[im];
im=ColorNegate[im];
(* Extract the various regions *)
res=WatershedComponents[im];
If[visualoutput==1,
Print[res//Colorize];
];
(* Get the various bits of information required *)
data=ComponentMeasurements[res,{"EquivalentDiskRadius","Centroid","Length","Width","Orientation"}];
(* Get data into a usable format *)
data = Map[Flatten[#[[2]]]&,data];
(* Remove largest element as this is the background *)
data=Most[Sort[data]];
(* Create a pair of lists first for NN second for MRL *)
data={Take[data,All,{1,3}],Take[data,All,{4,6}]};
(* Output the data *)
data
]


ConvertToOrientation[data_]:=Module[{output,i},
output=Table[{Mod [ArcTan[data[[i,1]],data[[i,2]]],Pi],Norm[data[[i]]]},{i,1,Length[data]}];
output
]


GetNearestNormalPointsDT[data_]:=Module[{reslist={},i,j, dist, distmin, jmin,factormin=0,factor,dtres,DT,dtdata,CH},
(* data expected to be in form radius, x, y *)
dtdata = Map[Take[#,{2,3}]&,data];
(* Get the corresponding Delaunay Triangulation *)
DT = DelaunayTriangulation[dtdata];
(* Get the Convex Hull *)
CH = ConvexHull[dtdata];
Table[
If[Not[MemberQ[CH,i]],
(* find the corresponding points in the DT *)
dtres =Select[DT,#[[1]]==i&];
Table[
factor=(data[[i,1]]+data[[j,1]]);
AppendTo[reslist,{(data[[i,2]]-data[[j,2]])/factor,(data[[i,3]]-data[[j,3]])/factor}];
AppendTo[reslist,-{(data[[i,2]]-data[[j,2]])/factor,(data[[i,3]]-data[[j,3]])/factor}];
,{j,dtres[[1,2]]}];
];
,{i,1,Length[data]}];
reslist
];


GetPlotDataPolar[data_]:=Module[{sdata,odata},
(* input data expected to be in form radius, x, y *)
sdata =  GetNearestNormalPointsDT[data];
 odata = ConvertToOrientation[sdata];
odata
]


AnalyseDataPolar[data_,zeta_]:=Module[{sdata,odata,a,b,p,y,t,func,res,Rsest1,tmp},
(* input data expected to be in form radius, x, y *)
sdata =  GetNearestNormalPointsDT[data];
 odata = ConvertToOrientation[sdata];
(* construct minimisation problem *)
func = Sum[(If[(a b Sqrt[1/(a^2+(-a^2+b^2) (Cos[p-t])^2)])>y,zeta,1](y-(a b Sqrt[1/(a^2+(-a^2+b^2) (Cos[p-t])^2)]))^2)/.{t->odata[[i,1]],y->odata[[i,2]]},{i,1,Length[odata]}];
(* minimise *)
res=FindMinimum[{func},{a,b,p}];
(* process solution *)
a = a/.res[[2]];b = b/.res[[2]];p = p/.res[[2]];
(* keep in range [0,Pi] *)
p = Mod[p,Pi];
(* adjust to make a > b always and modify p accordingly *)
If[b>a,tmp=a;a = b; b = tmp;p=Mod[p+Pi/2,Pi];];
(* output result *)
{a,b,p 180/Pi}
]


BootStrapPolar[data_,zeta_,reps_]:=Module[{sdata,odata,bdata,func,a,b,p,t,y,tmp,bootlist={},reslist,i,ar,br,pr ,res},
(* input data expected to be in form radius, x, y *)
sdata =  GetNearestNormalPointsDT[data];
 odata = ConvertToOrientation[sdata];
(* get actual solution *)
(* construct minimisation problem *)
func = Sum[(If[(a b Sqrt[1/(a^2+(-a^2+b^2) (Cos[p-t])^2)])>y,zeta,1](y-(a b Sqrt[1/(a^2+(-a^2+b^2) (Cos[p-t])^2)]))^2)/.{t->odata[[i,1]],y->odata[[i,2]]},{i,1,Length[odata]}];
(* minimise *)
res=FindMinimum[{func},{a,b,p}];
(* process solution *)
ar = a/.res[[2]];br = b/.res[[2]];pr = p/.res[[2]];
(* keep in range [0,Pi] *)
pr = Mod[pr,Pi];
(* adjust to make a > b always and modify p accordingly *)
If[br>ar,tmp=ar;ar = br; br = tmp;pr=Mod[pr+Pi/2,Pi];];
(* record the result *)
reslist={{ar/br,pr 180/Pi}};
(* do the bootstrap *)
For[i=0,i<reps,i++,
(* resample *)
bdata=RandomChoice[odata,Length[odata]];
(* Analyse *)
(* construct minimisation problem *)
func = Sum[(If[(a b Sqrt[1/(a^2+(-a^2+b^2) (Cos[p-t])^2)])>y,zeta,1](y-(a b Sqrt[1/(a^2+(-a^2+b^2) (Cos[p-t])^2)]))^2)/.{t->bdata[[i,1]],y->bdata[[i,2]]},{i,1,Length[bdata]}];
(* minimise *)
res=FindMinimum[{func},{a,b,p}];
(* process solution *)
ar = a/.res[[2]];br = b/.res[[2]];pr = p/.res[[2]];
(* keep in range [0,Pi] *)
pr = Mod[pr,Pi];
(* adjust to make a > b always and modify p accordingly *)
If[br>ar,tmp=ar;ar = br; br = tmp;pr=Mod[pr+Pi/2,Pi];];
(* put this value into the list *)
AppendTo[bootlist,{ar/br,pr 180/Pi}];
];
AppendTo[reslist,bootlist];
reslist
]


CreateNNPlotPolar[data_,result_]:=Module[{p1,p2,i,a,b,p,t,pdata},
(* data holds the raw data and result is the result of the NN analysis *)
pdata=GetPlotDataPolar[data];
p1=ListPlot[pdata,PlotStyle->{Gray,AbsolutePointSize[2]},Ticks->{Table[{i,180 i/Pi},{i,0,Pi,Pi/6}],Automatic},PlotRange->{{0,1.02Pi},{0,2}},AxesStyle->Directive[FontSize->18],AxesLabel->{Style["\[Theta]",30],Style["r",30]}];
p2=Plot[a b Sqrt[1/(a^2+(-a^2+b^2) Cos[p-t]^2)]/.{a->result[[1]],b->result[[2]],p->result[[3]] Pi/180},{t,0,Pi},PlotStyle->{Black,Dashed,AbsoluteThickness[2]}];
Show[p1,p2]
]


CreateBootStrapPlot[bootdata_,type_:1,ptcolour_:Gray,starcolour_:Black,contcolour_:Black]:=Module[{p1,p2,minx,maxx,miny,maxy,margx, margy,tmp,data},
(* bootdata holds the output from the bootstrap analysis *)
(* if type is 1 use Ellipsoidal Quantile *)
(* otherwise use polygonal quantiles *)
(* Determine a few parameters to be able to plot correctly *)
tmp = Take[bootdata[[2]],All,{1}];
minx = Min[tmp];
maxx = Max[tmp];
(* its more complicated with oriented data *)
data=Map[{#[[1]],Mod[#[[2]],180,bootdata[[1,2]]-90]}&,bootdata[[2]]];
tmp = Take[data,All,{2}];
miny = Min[tmp];
maxy = Max[tmp];
(* add a 40% margin *)
margx = (maxx-minx)*0.4;
margy = (maxy-miny)*0.4;
p1=ListPlot[{data,{bootdata[[1]]}},PlotStyle->{ptcolour,starcolour},PlotMarkers->{{\[FilledCircle],Tiny},{\[FivePointedStar],Large}},PlotRange->{{minx-margx,maxx+margx},{miny-margy,maxy+margy}},AxesLabel->{Style["R",30],Style["\[Phi]",30]},AxesStyle->Directive[FontSize->18]];
If[type==1,
p2=Graphics[Map[{contcolour,#}&,EllipsoidQuantile[data,{.9,.95,.99}]]];,
p2=Graphics[Map[{contcolour,#}&,PolytopeQuantile[data,{.9,.95,.99}]]];
];
Show[p1,p2]
]


GetPlotDataCartesian[data_]:=Module[{sdata},
(* input data expected to be in form radius, x, y *)
sdata =  GetNearestNormalPointsDT[data];
 sdata
]


CreateNNPlotCartesian[data_,result_]:=Module[{p1,p2, cartdata,i,a,b,p},
(* data holds the raw data and result is the result of the NN analysis *)
cartdata=GetPlotDataCartesian[data];
p1=ListPlot[cartdata,PlotRange->{{-3,3},{-3,3}},PlotStyle->{Gray,AbsolutePointSize[2]},AxesStyle->Directive[FontSize->18],AxesLabel->{Style["x",20],Style["y",20]},AspectRatio->Automatic,Ticks->False];
p2=Show[Graphics[Rotate[Circle[{0,0},{result[[1]],result[[2]]}], result[[3]]Pi/180]]];
Show[p1,p2]
]


MRL[data_]:=Module[{mdata,pdata,qs,ts,us,n=Length[data],i,Rs,phis},
(* data expected in the format {a,b,phi (in radians)} *)
mdata=Table[1/2((data[[i,1]]/data[[i,2]])-(data[[i,2]]/data[[i,1]])),{i,1,n}];
pdata=Table[1/2((data[[i,1]]/data[[i,2]])+(data[[i,2]]/data[[i,1]])),{i,1,n}];
qs=Mean[pdata];
ts=Sum[mdata[[i]]Cos[2data[[i,3]]],{i,1,n}]/n;
us=Sum[mdata[[i]]Sin[2data[[i,3]]],{i,1,n}]/n;
phis=Mod[1/2ArcTan[ts,us],Pi];
phis=1/2ArcTan[ts,us];
Rs=Sqrt[(qs Cos[2 phis]+ts)/(qs Cos[2 phis]-ts)];
{Rs,phis 180/Pi}
]


BootStrapMRL[data_,reps_]:=Module[{act,n = Length[data],bdata,bres},
act=MRL[data];
(* do the bootstrap *)
bres=Table[bdata=RandomChoice[data,n];MRL[bdata],{i,1,reps}];
{act,bres}
]
